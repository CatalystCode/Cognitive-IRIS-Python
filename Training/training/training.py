# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator 1.0.1.0
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import ServiceClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError
from . import models


class TrainingConfiguration(Configuration):
    """Configuration for Training
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param str base_url: Service URL
    """

    def __init__(
            self, base_url=None):

        if not base_url:
            base_url = 'https://customvisionppe.azure-api.net/v1.0/Training'

        super(TrainingConfiguration, self).__init__(base_url)

        self.add_user_agent('training/{}'.format(VERSION))


class Training(object):
    """Training

    :ivar config: Configuration for client.
    :vartype config: TrainingConfiguration

    :param str base_url: Service URL
    """

    def __init__(
            self, base_url=None):

        self.config = TrainingConfiguration(base_url)
        self._client = ServiceClient(None, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = '1.0'
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)


    def get_projects(
            self, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """Gets the user's projects.

        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: list of :class:`ProjectModel <training.models.ProjectModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/'

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ProjectModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_project(
            self, training_key=None, training_key1=None, project_update_model=None, custom_headers=None, raw=False, **operation_config):
        """Create a project.

        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param project_update_model: information about the project to be
         created
        :type project_update_model: :class:`ProjectUpdateModel
         <training.models.ProjectUpdateModel>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`ProjectModel <training.models.ProjectModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/'

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct body
        if project_update_model is not None:
            body_content = self._serialize.body(project_update_model, 'ProjectUpdateModel')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ProjectModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_project(
            self, project_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """Delete a specific project.

        :param project_id: Format - uuid. Guid of the projectId
        :type project_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: None
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def update_project(
            self, project_id, training_key=None, training_key1=None, project_update_model=None, custom_headers=None, raw=False, **operation_config):
        """Update a specific project.

        :param project_id: Format - uuid.
        :type project_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param project_update_model:
        :type project_update_model: :class:`ProjectUpdateModel
         <training.models.ProjectUpdateModel>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`ProjectModel <training.models.ProjectModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct body
        if project_update_model is not None:
            body_content = self._serialize.body(project_update_model, 'ProjectUpdateModel')
        else:
            body_content = None

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ProjectModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_classes(
            self, project_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """Get's the project classes.

        :param project_id: Format - uuid.
        :type project_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: list of :class:`ImageClassModel
         <training.models.ImageClassModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/classes'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ImageClassModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_class(
            self, project_id, name, description=None, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """Creates a class for the project.

        :param project_id: Format - uuid.
        :type project_id: str
        :param name:
        :type name: str
        :param description:
        :type description: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`ImageClassModel <training.models.ImageClassModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/classes'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['name'] = self._serialize.query("name", name, 'str')
        if description is not None:
            query_parameters['description'] = self._serialize.query("description", description, 'str')
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ImageClassModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_class_images(
            self, project_id, class_id, take=50, skip=0, max_category_rank=1, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """This API supports batching and range selection. By default it will only
        return the first 50 images in a class.
        Use the {take} and {skip} parameters to control how many images to
        return in a given batch.
        If the total number of images in the class is less than ({skip} +
        {take}) the number of images returned will be less than {take}.

        :param project_id: Format - uuid. The id of the project the class is
         part of
        :type project_id: str
        :param class_id: Format - uuid. The id of the class to get images for
        :type class_id: str
        :param take: Format - int32. Maximum number of images to return.
         Defaults to 50
        :type take: int
        :param skip: Format - int32. How many images should be skipped before
         begining the image batch. Defaults to 0
        :type skip: int
        :param max_category_rank: Format - int32. The maximum number of
         categories to return. Defaults to 1
        :type max_category_rank: int
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: list of :class:`ImageModelObsolete
         <training.models.ImageModelObsolete>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/classes/{classId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'classId': self._serialize.url("class_id", class_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if take is not None:
            query_parameters['take'] = self._serialize.query("take", take, 'int')
        if skip is not None:
            query_parameters['skip'] = self._serialize.query("skip", skip, 'int')
        if max_category_rank is not None:
            query_parameters['maxCategoryRank'] = self._serialize.query("max_category_rank", max_category_rank, 'int')
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ImageModelObsolete]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_class(
            self, project_id, class_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """Delete a class for the project.

        :param project_id: Format - uuid.
        :type project_id: str
        :param class_id: Format - uuid.
        :type class_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: None
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/classes/{classId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'classId': self._serialize.url("class_id", class_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def update_class(
            self, project_id, class_id, name, description=None, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """Updates a class for the project.

        :param project_id: Format - uuid.
        :type project_id: str
        :param class_id: Format - uuid.
        :type class_id: str
        :param name:
        :type name: str
        :param description:
        :type description: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`ImageClassModel <training.models.ImageClassModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/classes/{classId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'classId': self._serialize.url("class_id", class_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['name'] = self._serialize.query("name", name, 'str')
        if description is not None:
            query_parameters['description'] = self._serialize.query("description", description, 'str')
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ImageClassModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def train_project(
            self, project_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """Queues training of the current iteration for the project.

        :param project_id: Format - uuid. The project id.
        :type project_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`IterationModel <training.models.IterationModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/train'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('IterationModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_iterations(
            self, project_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """Get iterations for the project.

        :param project_id: Format - uuid. The project id.
        :type project_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: list of :class:`IterationModel
         <training.models.IterationModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/iterations'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[IterationModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_iteration(
            self, project_id, iteration_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """Get a specific iteration.

        :param project_id: Format - uuid. The id of the project the iteration
         belongs to
        :type project_id: str
        :param iteration_id: Format - uuid. The id of the iteration to get
        :type iteration_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`IterationModel <training.models.IterationModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/iterations/{iterationId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'iterationId': self._serialize.url("iteration_id", iteration_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('IterationModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_iteration(
            self, project_id, iteration_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param iteration_id: Format - uuid.
        :type iteration_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: None
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/iterations/{iterationId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'iterationId': self._serialize.url("iteration_id", iteration_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def update_iteration(
            self, project_id, iteration_id, name, note=None, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param iteration_id: Format - uuid.
        :type iteration_id: str
        :param name:
        :type name: str
        :param note:
        :type note: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`IterationModel <training.models.IterationModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/iterations/{iterationId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'iterationId': self._serialize.url("iteration_id", iteration_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['name'] = self._serialize.query("name", name, 'str')
        if note is not None:
            query_parameters['note'] = self._serialize.query("note", note, 'str')
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('IterationModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def rollback_iteration(
            self, project_id, iteration_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param iteration_id: Format - uuid.
        :type iteration_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`IterationModel <training.models.IterationModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/iterations/current/{iterationId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'iterationId': self._serialize.url("iteration_id", iteration_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('IterationModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def put_default_iteration(
            self, project_id, iteration_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param iteration_id: Format - uuid.
        :type iteration_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: None
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/iterations/default/{iterationId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'iterationId': self._serialize.url("iteration_id", iteration_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_user_images_by_class(
            self, project_id, iteration_id, class_id, max_category_rank=None, max_count=None, continuation_token=None, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param iteration_id: Format - uuid.
        :type iteration_id: str
        :param class_id: Format - uuid.
        :type class_id: str
        :param max_category_rank: Format - int32.
        :type max_category_rank: int
        :param max_count: Format - int32.
        :type max_count: int
        :param continuation_token:
        :type continuation_token: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`UserImageResults <training.models.UserImageResults>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/{iterationId}/userImages/class'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'iterationId': self._serialize.url("iteration_id", iteration_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['classId'] = self._serialize.query("class_id", class_id, 'str')
        if max_category_rank is not None:
            query_parameters['maxCategoryRank'] = self._serialize.query("max_category_rank", max_category_rank, 'int')
        if max_count is not None:
            query_parameters['maxCount'] = self._serialize.query("max_count", max_count, 'int')
        if continuation_token is not None:
            query_parameters['continuationToken'] = self._serialize.query("continuation_token", continuation_token, 'str')
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserImageResults', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_user_images_by_time(
            self, project_id, iteration_id, start_time=None, end_time=None, ascending=None, max_count=None, continuation_token=None, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param iteration_id: Format - uuid.
        :type iteration_id: str
        :param start_time: Format - date-time (as date-time in RFC3339).
        :type start_time: str
        :param end_time: Format - date-time (as date-time in RFC3339).
        :type end_time: str
        :param ascending:
        :type ascending: bool
        :param max_count: Format - int32.
        :type max_count: int
        :param continuation_token:
        :type continuation_token: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`UserImageResults <training.models.UserImageResults>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/{iterationId}/userImages/time'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'iterationId': self._serialize.url("iteration_id", iteration_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if start_time is not None:
            query_parameters['startTime'] = self._serialize.query("start_time", start_time, 'str')
        if end_time is not None:
            query_parameters['endTime'] = self._serialize.query("end_time", end_time, 'str')
        if ascending is not None:
            query_parameters['ascending'] = self._serialize.query("ascending", ascending, 'bool')
        if max_count is not None:
            query_parameters['maxCount'] = self._serialize.query("max_count", max_count, 'int')
        if continuation_token is not None:
            query_parameters['continuationToken'] = self._serialize.query("continuation_token", continuation_token, 'str')
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserImageResults', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def archive_user_images(
            self, project_id, iteration_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param iteration_id: Format - uuid.
        :type iteration_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: None
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/{iterationId}/userImages/archive'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'iterationId': self._serialize.url("iteration_id", iteration_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_image(
            self, project_id, image_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """Gets the requested image stream.

        :param project_id: Format - uuid. The project guid.
        :type project_id: str
        :param image_id: Format - uuid. The image guid.
        :type image_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: object
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/images/{imageId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'imageId': self._serialize.url("image_id", image_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200 and raw == False:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_thumbnail(
            self, project_id, image_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param image_id: Format - uuid.
        :type image_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: object
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/thumbnails/{imageId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'imageId': self._serialize.url("image_id", image_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def post_image_urls_for_class(
            self, project_id, class_id, training_key=None, training_key1=None, image_url_batch=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param class_id: Format - uuid.
        :type class_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param image_url_batch:
        :type image_url_batch: :class:`ImageUrlBatch
         <training.models.ImageUrlBatch>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`ImageUploadSummary
         <training.models.ImageUploadSummary>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/images/{classId}/url'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'classId': self._serialize.url("class_id", class_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct body
        if image_url_batch is not None:
            body_content = self._serialize.body(image_url_batch, 'ImageUrlBatch')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ImageUploadSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def post_images_for_class(
            self, project_id, class_id, image_data, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param class_id: Format - uuid.
        :type class_id: str
        :param image_data:
        :type image_data: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`ImageUploadSummary
         <training.models.ImageUploadSummary>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/images/{classId}/image'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'classId': self._serialize.url("class_id", class_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'multipart/form-data'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct form data
        form_data_content = {
            'imageData': image_data,
        }

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send_formdata(
            request, header_parameters, form_data_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ImageUploadSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_images(
            self, project_id, training_key=None, training_key1=None, image_ids=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param image_ids:
        :type image_ids: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: None
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/images'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct body
        if image_ids is not None:
            body_content = self._serialize.body(image_ids, '[str]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_images(
            self, project_id, iteration_id=None, tag_ids=None, performance_filter=None, order_by=None, take=50, skip=0, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """This API supports batching and range selection. By default it will only
        return first 50 images matching images.
        Use the {take} and {skip} parameters to control how many images to
        return in a given batch.
        If the total number of images is less than ({skip} + {take})
        the number of images returned will be less than {take}.

        :param project_id: Format - uuid. The project id
        :type project_id: str
        :param iteration_id: Format - uuid. The iteration id. This will
         default to the current iteration
        :type iteration_id: str
        :param tag_ids: An optional list of tags ids to filter the images. For
         example, the API only return images tagged
         with "Dog" and "Cat" if specified. Otherwise, it will consider all
         tags
        :type tag_ids: str
        :param performance_filter: The performance filter to apply. This will
         only be valid when querying trained iterations. Possible values
         include: 'None', 'Correct', 'Incorrect'
        :type performance_filter: str
        :param order_by: The ordering. Defaults to newest. Possible values
         include: 'Newest', 'Oldest'
        :type order_by: str
        :param take: Format - int32. Maximum number of images to return.
         Defaults to 50
        :type take: int
        :param skip: Format - int32. How many images should be skipped before
         begining the image batch. Defaults to 0
        :type skip: int
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: list of :class:`ImageModel <training.models.ImageModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/images'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if iteration_id is not None:
            query_parameters['iterationId'] = self._serialize.query("iteration_id", iteration_id, 'str')
        if tag_ids is not None:
            query_parameters['tagIds'] = self._serialize.query("tag_ids", tag_ids, 'str')
        if performance_filter is not None:
            query_parameters['performanceFilter'] = self._serialize.query("performance_filter", performance_filter, 'str')
        if order_by is not None:
            query_parameters['orderBy'] = self._serialize.query("order_by", order_by, 'str')
        if take is not None:
            query_parameters['take'] = self._serialize.query("take", take, 'int')
        if skip is not None:
            query_parameters['skip'] = self._serialize.query("skip", skip, 'int')
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ImageModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def change_image_label(
            self, project_id, image_id, class_id, training_key=None, training_key1=None, image_region=None, custom_headers=None, raw=False, **operation_config):
        """Changes the image's class.

        :param project_id: Format - uuid. The project id.
        :type project_id: str
        :param image_id: Format - uuid. The image id.
        :type image_id: str
        :param class_id: Format - uuid. The class id.
        :type class_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param image_region:
        :type image_region: :class:`ImageRegion <training.models.ImageRegion>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`ImageModelObsolete
         <training.models.ImageModelObsolete>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/image/{imageId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'imageId': self._serialize.url("image_id", image_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['classId'] = self._serialize.query("class_id", class_id, 'str')
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct body
        if image_region is not None:
            body_content = self._serialize.body(image_region, 'ImageRegion')
        else:
            body_content = None

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ImageModelObsolete', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_image_thumbnail(
            self, project_id, image_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """Gets the requested thumbnail stream for the image.

        :param project_id: Format - uuid. The project guid.
        :type project_id: str
        :param image_id: Format - uuid. The image guid.
        :type image_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: object
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/images/{imageId}/thumbnail'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'imageId': self._serialize.url("image_id", image_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def post_image_urls(
            self, project_id, training_key=None, training_key1=None, image_url_create_batch=None, custom_headers=None, raw=False, **operation_config):
        """Adds the provided images to the current project iteration.

        :param project_id: Format - uuid. The project id.
        :type project_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param image_url_create_batch: Image urls and tag ids
        :type image_url_create_batch: :class:`ImageUrlCreateBatch
         <training.models.ImageUrlCreateBatch>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`ImageUploadSummary
         <training.models.ImageUploadSummary>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/images/url'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct body
        if image_url_create_batch is not None:
            body_content = self._serialize.body(image_url_create_batch, 'ImageUrlCreateBatch')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ImageUploadSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def post_images(
            self, project_id, image_data, image_data1, training_key=None, training_key1=None, tag_ids=None, custom_headers=None, raw=False, **operation_config):
        """Adds the provided images to the current project iteration.

        :param project_id: Format - uuid. The project id.
        :type project_id: str
        :param image_data:
        :type image_data: str
        :param image_data1:
        :type image_data1: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param tag_ids: The tags ids to associate with the image batch.
        :type tag_ids: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`ImageUploadSummary
         <training.models.ImageUploadSummary>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/images/image'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct body
        if tag_ids is not None:
            body_content = self._serialize.body(tag_ids, '[str]')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ImageUploadSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def post_image_label(
            self, project_id, image_id, training_key=None, training_key1=None, image_label_create_model=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param image_id: Format - uuid.
        :type image_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param image_label_create_model:
        :type image_label_create_model: :class:`ImageLabelCreateModel
         <training.models.ImageLabelCreateModel>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`ImageModel <training.models.ImageModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/image/{imageId}/label'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'imageId': self._serialize.url("image_id", image_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct body
        if image_label_create_model is not None:
            body_content = self._serialize.body(image_label_create_model, 'ImageLabelCreateModel')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ImageModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_image_label(
            self, project_id, image_id, label_id, training_key=None, training_key1=None, custom_headers=None, raw=False, **operation_config):
        """

        :param project_id: Format - uuid.
        :type project_id: str
        :param image_id: Format - uuid.
        :type image_id: str
        :param label_id: Format - uuid.
        :type label_id: str
        :param training_key: subscription key in url
        :type training_key: str
        :param training_key1: subscription key in header
        :type training_key1: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :rtype: :class:`ImageModel <training.models.ImageModel>`
        :rtype: :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
         if raw=true
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/{projectId}/image/{imageId}/label/{labelId}'
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'imageId': self._serialize.url("image_id", image_id, 'str'),
            'labelId': self._serialize.url("label_id", label_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if training_key is not None:
            query_parameters['Training-key'] = self._serialize.query("training_key", training_key, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if training_key1 is not None:
            header_parameters['Training-key'] = self._serialize.header("training_key1", training_key1, 'str')

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ImageModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
